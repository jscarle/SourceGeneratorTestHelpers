using System.Collections.Immutable;
using System.Text;
using Basic.Reference.Assemblies;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace SourceGeneratorTestHelpers.Common;

internal static class Helpers
{
    internal static CSharpParseOptions DefaultCSharpParseOptions { get; } = new(LanguageVersion.Latest);
    internal static IEnumerable<MetadataReference> DefaultMetadataReferences { get; } = NetStandard20.References.All;

    internal static CSharpCompilationOptions DefaultCSharpCompilationOptions { get; } =
        new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary).WithNullableContextOptions(NullableContextOptions.Enable);

    internal static (ImmutableArray<Diagnostic> CompilationDiagnostics, GeneratorDriverRunResult Result) InternalRunGenerator(
        ISourceGenerator generator,
        string source,
        CSharpParseOptions? cSharpParseOptions,
        IEnumerable<MetadataReference>? metadataReferences,
        CSharpCompilationOptions? cSharpCompilationOptions
    )
    {
        var sources = new[] { source };

        return InternalRunGenerator(generator, sources, cSharpParseOptions, metadataReferences, cSharpCompilationOptions);
    }

    internal static (ImmutableArray<Diagnostic> CompilationDiagnostics, GeneratorDriverRunResult Result) InternalRunGenerator(
        ISourceGenerator generator,
        IEnumerable<string> sources,
        CSharpParseOptions? cSharpParseOptions,
        IEnumerable<MetadataReference>? metadataReferences,
        CSharpCompilationOptions? cSharpCompilationOptions
    )
    {
        var syntaxTrees = sources.Select(source => CSharpSyntaxTree.ParseText(source, cSharpParseOptions, encoding: Encoding.UTF8)).ToArray();
        cSharpParseOptions ??= DefaultCSharpParseOptions;
        metadataReferences ??= DefaultMetadataReferences;
        cSharpCompilationOptions ??= DefaultCSharpCompilationOptions;

        var compilation = CSharpCompilation.Create(nameof(SourceGeneratorTestHelpers), syntaxTrees, metadataReferences, cSharpCompilationOptions);
        var generators = new[] { generator };
        var driver = CSharpGeneratorDriver.Create(generators, null, cSharpParseOptions);
        var updatedDriver = driver.RunGeneratorsAndUpdateCompilation(
            compilation,
            out var updatedCompilation,
            out var generatorDiagnostics);
        var compilationDiagnostics = updatedCompilation.GetDiagnostics();
        var allDiagnostics = compilationDiagnostics.AddRange(generatorDiagnostics);
        var runResult = updatedDriver.GetRunResult();

        return (allDiagnostics, runResult);
    }

    internal static void InternalAssertOnDiagnostics(
        this ImmutableArray<Diagnostic> diagnostics,
        bool assertOnErrors,
        bool assertOnWarnings,
        Action<string> assertAction,
        string reason
    )
    {
        var errors = diagnostics.Where(diagnostic => diagnostic.Severity == DiagnosticSeverity.Error).ToList();
        if (assertOnErrors && errors.Count > 0)
            assertAction(errors.ToMessage(reason));

        var warnings = diagnostics.Where(diagnostic => diagnostic.Severity == DiagnosticSeverity.Warning).ToList();
        if (assertOnWarnings && warnings.Count > 0)
            assertAction(warnings.ToMessage(reason));
    }

    internal static void InternalShouldProduce(
        this GeneratorDriverRunResult result,
        string filePathEndsWith,
        string expectedSource,
        bool assertOnErrors,
        bool assertOnWarnings,
        Action<string> assertAction
    )
    {
        result.Diagnostics.InternalAssertOnDiagnostics(
            assertOnErrors,
            assertOnWarnings,
            assertAction,
            "There were errors in the output generated by the source generator."
        );

        var generatedSource = InternalGetSource(result, filePathEndsWith);

        // ReSharper disable once NullCoalescingConditionIsAlwaysNotNullAccordingToAPIContract
        var (hasDifferences, differences) = Diff.Compare(expectedSource ?? "", generatedSource?.Source ?? "");
        if (hasDifferences)
            assertAction($"There was a difference in the expected output generated by the source generator.\n\n{differences}");
    }

    internal static GeneratedSource? InternalGetSource(this GeneratorDriverRunResult result, string filePathEndsWith)
    {
        var sources = InternalGetSources(result);

        var matchingSources = sources.Where(x => x.FilePath.EndsWith(filePathEndsWith, StringComparison.InvariantCultureIgnoreCase)).ToList();

        return matchingSources.Count == 0 ? null : matchingSources[0];
    }

    internal static ImmutableList<GeneratedSource> InternalGetSources(this GeneratorDriverRunResult result)
    {
        return result.GeneratedTrees.Select(GetGeneratedSource).ToImmutableList();
    }

    private static string ToMessage(this IEnumerable<Diagnostic> diagnostics, string reason)
    {
        var separator = $"{Environment.NewLine} - ";

        var message = $"{reason}{Environment.NewLine}{separator}{string.Join(separator, diagnostics.Select(x => x.ToString()))}{Environment.NewLine}";

        return message;
    }

    private static GeneratedSource GetGeneratedSource(SyntaxTree tree)
    {
        var filePath = tree.FilePath;
        var source = tree.GetText().ToString();

        return new GeneratedSource(filePath, source);
    }
}
